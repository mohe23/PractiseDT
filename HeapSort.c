// 堆排序（顺序表，结果升序）-选择排序

#include<stdio.h>
#include<stdlib.h>

void HeapAdjust(int b[],int s,int m){// 调整成堆。数组b中有效数据从下标1开始存储。s,m：是数组中有待调整数据范围，下标的最小值与最大值
     int i,t;  // s+1至m已经是堆，函数的目的：将s至m调整成堆                     s>=1
     t=b[s];
     for(i=2*s;i<=m;i*=2){// 通过该循环，找到重新调整成推时，b[s]的正确位置的下标
         if(i<m&&b[i]<b[i+1])// 找出b[2s]与b[2s+1]的较大者。i<m：为了确保下标（i+1）不超出m
            i++;// 找出b[2s]与b[2s+1]的较大者
         if(t<b[i]){// 待排序元素b[s] < b[i](b[s]的2个儿子的较大值)
            b[s]=b[i];//将较大的“儿子”赋值到下标为s的位置
            s=i;//此时，相当于b[s]（一开始的）“赋值”到此时的b[i]里，但是b[s]没有真正赋值，让b[s]继续向下比较，知道找到正确位置
         }
         else// 此时，b[s]>=b[2s],b[s]>=b[2s+1]，已经成为大根堆了。
            break;
     }
     b[s]=t;//此时一开始的b[s]找到了在大根堆的正确位置,此时s已经与初始s值不同
}

void CreateHeap(int b[],int ble){//建初堆函数。此时数组b中的“有效数据”从下标1开始存储。ble-数组b的长度
    int i;         // 一开始，我想把ble表示成数组b最后1个元素的下标，但是这样做不好，破坏了函数的可读性，还有调用该函数时，参数的值
    ble--;//此时ble-表示数组最后1个元素的下标                                                             也要注意，不利于调用该函数
    for(i=ble/2;i>0;i--)// 对所有非叶子端点，都调用1个调整成堆（大根）算法，最终建成1个大根堆。
        HeapAdjust(b,i,ble);
}

void HeapSort(int b[],int ble){// 堆排序算法
    int i,t;
    ble--;//此时ble：最后1个元素的下标。数组b从下标1开始存储元素。
    CreateHeap(b,ble);//建立初始大根堆
    for(i=ble;i>1;i--){
        t = b[1];// 交换b[1]与b[i]，将最大值赋值到数组当前排序序列尾部。
        b[1] = b[i];
        b[i] = t;
        HeapAdjust(b,1,i-1);//调整下标从1到i，成为大根堆。注意这里一定要注意第3个参数是“i-1”，不能是i。b[i]已经是当前“最大值”，正确
                                      // 位置
    }
}
